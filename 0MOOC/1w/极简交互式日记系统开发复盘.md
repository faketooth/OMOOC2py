# 极简交互式日记系统开发复盘
大妈果然是花式虐菜的高手。按照 [大妈的点评](https://github.com/OpenMindClub/OMOOC2py/issues/31#issuecomment-149579227) 顺序，逐一复盘。

## 1. 为何48小时之后才释放笔记
>- 先点赞,然后
- 嗯哼?! 已经完成48小时现在才释放笔记?!

其实笔记是周一晚上才补出来的，直接提交到了`gitbook`那边。周日晚上做的事情是按照芝麻星卡片编写代码，然后简单写了一份`README.md`，介绍一下脚本功能，记录了几个`git`命令，就`push`到了`gitbook`的仓库。

看到了 @ZoeJane 的 [[1w任务尝试]小小日记](https://github.com/OpenMindClub/OMOOC2py/issues/26) 后，也动了分享的念头。从效果上来看，收获颇多。


## 2. github 及 git 连珠炮
> - 严令要沉浸 github 生态
- 为何要这么折腾 git 仓库!?
- 给仓库链接不就好了!?
- 在版本仓库中应该放什么文件?!
    + 这是一个基础又严肃以及非常细思恐极的问题
    + 涉及:
        * 什么是版本
        * 什么是版本仓库
        * 仓库的使命是什么
        * 什么是工程文件
        * ....
    - 请 24 小时以内认真回答,并形成私人教程章节公开出来

对工程文件的每一次编辑之后的保存，都可以视为产生了一个新的版本。当然这是基于个人理解给出的定义。

而版本仓库则是存储整个项目历史变更的地方，包括目录结构变更、代码变更、文档变更等，变更可以是增、删、改。版本仓库的存在，可以保证项目变更可追溯、可回滚。

工程文件包括项目代码、项目文档等，实际内容跟项目具体内容相关。

这里已知的犯下的错误有：

* 把版本仓库当成了网盘来用
* 版本仓库的目录结构、文件组织混乱，提交了一些无用文件到仓库中
* 对于可用版本的把控不够明确，出现了多次可用版本变更没有逐次`commit`到仓库中

改进措施：

* 整理仓库中的工程文件，规划对应的目录结构，将项目文件分门别类存放
* 培养每个良好的可用版本进行`commit`的习惯，保证每次版本有效变更都体现在仓库的历史记录中
* 加强`git`学习：https://git-scm.com/doc

## 3. 关于自作主张
>- 大爱这种自作主张!
- 嘦注意,先完成看不上眼的功能
    + 然后看看自个儿在允许的时间里能将功能扩展到什么程度!?
    + 当然,过程中的所有折腾都应该记录下来
    + 并自个儿总结:
        * 哪些很容易就实现了
        * 哪些相反
        * 这种和自个儿的目测情况不匹配的情况,多数是怎么发生的?!
        * 原因何在?
        * 自个儿在什么领域的目测很准? 什么领域是相反?
            - 为什么?
            - 如何改进?!
            - 哪种改进方式最合适自个儿?!
            - 为什么?
            - 这种经验能复用在其它人身上嘛?!
            - ...

大妈所说的“目测”是`Trial and Error`中很重要的一个环境，通过“目测”来挑选`Trial`的方向。这次的练习没有遭遇多少需要探索的问题，倒是上周写 XML 解析脚本的时候颇有感受。

第一次写 Python 脚本解析 XML 文件，搜索过后发现提供了多个库可以实现相关功能，根据网上的建议，选择了 cElementTree 来做。脚本写了一半，发现原始 XML 文件中存在 CDATA 标签，cElementTree无法读取其中的内容，而这次脚本解析最重要的目的就是获取 CDATA 标签中的内容。

CDATA 中的数据则是 jason 格式，使用 json 模块解析时遭遇 UnicodeError ，使用 decode 函数解决问题之后，算是遗留了一个`TODO`，计划两天内解决。

`Trial and Error`还会获得额外的收获，`logging`模块的基本使用就是借助这个机会得到了学习。

## 4. 关于迭代
>- 有证据嘛!?
- 迭代过程都有版本历史嘛?!
- 代码是越来越少,还是越来越多?
- 功能的增加,代码必须增加嘛?
- 为什么?
- 能更加优雅些嘛?
- 有什么好处?!

说实话，没证据……

目前还需要继续培养每次可用版本之后`commit`的习惯，所以五轮迭代版本记录全部丢失。

从这次迭代的经验来看，功能的增加导致了代码的增加。例如为支持参数传入，添加了`sys.argv`相关的操作；为将日记写入文件，增加了`logging`模块的相关调用。可实际上，功能的增加与代码的增加没有必然关系，甚至有可能在功能增加的同时，项目代码量出现减少的情况。这应该算是重构的功劳。

而且，良好的代码重构可以使代码更加优雅。道理跟写文章有点像，第一稿通常都是最差的，需要后面不断的修修补补，调整措辞和行文结构之类的。而优雅的代码和与优雅的文章一样，都能让阅读它的人觉得心情舒畅，发现作者的精工巧思。



